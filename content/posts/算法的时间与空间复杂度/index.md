---
title: 算法的时间与空间复杂度
date: 2021-09-02
tags:
  - 算法 & 数据结构
categories:
  - 笔记
---

算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。

那么我们应该如何去衡量不同算法之间的优劣呢？

主要还是从算法所占用的「时间」和「空间」两个维度去考量。

- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。

下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。

## 时间复杂度

我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。

这种方式可以吗？当然可以，不过它也有很多弊端。

这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。

因此，另一种更为通用的方法就出来了：「 大 {{<katex>}}O{{</katex>}}符号表示法 」，即 {{<katex>}}T(n) = O(f(n)){{</katex>}}

我们先来看个例子：

```c
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

通过「 大 {{<katex>}}O{{</katex>}}符号表示法 」，这段代码的时间复杂度为：{{<katex>}}O(n){{</katex>}} ，为什么呢?

在 大 {{<katex>}}O{{</katex>}}符号表示法中，时间复杂度的公式是：{{<katex>}}T(n) = O( f(n) ){{</katex>}}，其中{{<katex>}}f(n){{</katex>}}表示每行代码执行次数之和，而{{<katex>}}O{{</katex>}}表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**。

我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1 颗粒时间来表示，那么这个例子的第一行耗时是 1 个颗粒时间，第三行的执行时间是 n 个颗粒时间，第四行的执行时间也是 n 个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1 颗粒时间 + n 颗粒时间 + n 颗粒时间 ，即 (1+2n) 个颗粒时间，即：{{<katex>}}T(n) = (1+2n)^x{{</katex>}} 颗粒时间，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：{{<katex>}}T(n) = O(n){{</katex>}}

为什么可以这么去简化呢，因为大 {{<katex>}}O{{</katex>}} 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

所以上面的例子中，如果 n 无限大的时候，{{<katex>}}T(n) = time(1+2n){{</katex>}}中的常量 1 就没有意义了，倍数 2 也意义不大。因此直接简化为{{<katex>}}T(n) = O(n){{</katex>}}就可以了。

常见的时间复杂度量级有：

- 常数阶 {{<katex>}}O(1){{</katex>}}
- 对数阶 {{<katex>}}O(logN){{</katex>}}
- 线性阶 {{<katex>}}O(n){{</katex>}}
- 线性对数阶 {{<katex>}}O(nlogN){{</katex>}}
- 平方阶 {{<katex>}}O(n^2){{</katex>}}
- 立方阶 {{<katex>}}O(n^3){{</katex>}}
- K 次方阶 {{<katex>}}O(n^k){{</katex>}}
- 指数阶 {{<katex>}}(2^n){{</katex>}}

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

下面选取一些较为常用的来讲解一下（没有严格按照顺序）：

### 常数阶

{{<katex>}}O(1){{</katex>}}

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)，如：

```c
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用 {{<katex>}}O(1){{</katex>}} 来表示它的时间复杂度。

### 线性阶

{{<katex>}}O(n){{</katex>}}

这个在最开始的代码示例中就讲解过了，如：

```c
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 {{<katex>}}O(n){{</katex>}} 来表示它的时间复杂度。

### 对数阶

{{<katex>}}O(logN){{</katex>}}

还是先来看代码：

```c
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

从上面代码可以看到，在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 {{<katex>}}x = log2^n{{</katex>}}

也就是说当循环 {{<katex>}}log2^n{{</katex>}} 次以后，这个代码就结束了。因此这个代码的时间复杂度为：{{<katex>}}O(logN){{</katex>}}

### 线性对数阶 

{{<katex>}}O(nlogN){{</katex>}}

线性对数阶 {{<katex>}}O(nlogN){{</katex>}} 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 {{<katex>}}n * O(logN){{</katex>}} ，也就是了 {{<katex>}}O(nlogN){{</katex>}} 。

就拿上面的代码加一点修改来举例

```c
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

### 平方阶

{{<katex>}}O(n^2){{</katex>}}

平方阶{{<katex>}}O(n^2){{</katex>}}就更容易理解了，如果把{{<katex>}}O(n){{</katex>}}的代码再嵌套循环一遍，它的时间复杂度就是{{<katex>}}O(n^2){{</katex>}}了。举例：

```c
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是{{<katex>}}O(n\*n){{</katex>}}，即 {{<katex>}}O(n^2){{</katex>}}

如果将其中一层循环的 n 改成 m，即：

```c
for(x=1; x<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

那它的时间复杂度就变成了{{<katex>}}O(m\*n){{</katex>}}

### 立方阶、K 次方阶

参考上面的{{<katex>}}O(n^2){{</katex>}}去理解就好了，{{<katex>}}O(n^3){{</katex>}}相当于三层 n 循环，其它的类似。

除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。

## 空间复杂度

既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

空间复杂度比较常用的有：{{<katex>}}O(1){{</katex>}}、{{<katex>}}O(n){{</katex>}}、{{<katex>}}O(n^2){{</katex>}}，我们下面来看看：

### 空间复杂度

{{<katex>}}O(1){{</katex>}}

如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为{{<katex>}}O(1){{</katex>}}。举例：

```c
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 {{<katex>}}S(n) = O(1){{</katex>}}

### 空间复杂度

{{<katex>}}O(n){{</katex>}}

我们先看一个代码：

```c
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 {{<katex>}}S(n) = O(n){{</katex>}}

> 作者：不止思考(奎哥) <br>
> 原文：<https://zhuanlan.zhihu.com/p/50479555>
