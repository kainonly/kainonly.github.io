<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Angular 动态创建组件之 Portals - Kain&#039;s Notes</title><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kainonly.com/front-end/angular_portals/"},"headline":"Angular 动态创建组件之 Portals","image":["https://kainonly.com/img/angular_portals/elem1.jpg","https://kainonly.com/img/angular_portals/elem2.jpg","https://kainonly.com/img/angular_portals/elem3.jpg","https://kainonly.com/img/angular_portals/elem4.jpg"],"datePublished":"2021-05-31T01:01:34.492Z","dateModified":"2021-05-31T02:24:00.596Z","author":{"@type":"Person","name":"Kain"},"description":"这篇文章主要介绍使用 Angular api 和 CDK Portals 两种方式实现动态创建组件，另外还会讲一些跟它相关的知识点，如：Angular 多级依赖注入、ViewContainerRef，Portals 可以翻译为 门户 ，我觉得放到这里叫 入口 更好，可以理解为动态创建组件的入口，类似于小程序或者 Vue 中的 Slot. 作者：pubuzhixing链接：https:&#x2F;&#x2F;zhuan"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/vs2015.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-J0NVPEBDTM" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-J0NVPEBDTM');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Kain&#039;s Notes" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.yuque.com/kainonly">语雀</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/archives">归档</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/kainonly"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-31T01:01:34.492Z" title="2021/5/31 上午9:01:34">2021-05-31</time>发表</span><span class="level-item"><time dateTime="2021-05-31T02:24:00.596Z" title="2021/5/31 上午10:24:00">2021-05-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a></span><span class="level-item">19 分钟读完 (大约2910个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Angular 动态创建组件之 Portals</h1><div class="content"><p>这篇文章主要介绍使用 Angular api 和 CDK Portals 两种方式实现动态创建组件，另外还会讲一些跟它相关的知识点，如：Angular 多级依赖注入、ViewContainerRef，Portals 可以翻译为 门户 ，我觉得放到这里叫 入口 更好，可以理解为动态创建组件的入口，类似于小程序或者 Vue 中的 Slot.</p>
<p>作者：pubuzhixing<br>链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59719621">https://zhuanlan.zhihu.com/p/59719621</a></p>
<span id="more"></span>

<h2 id="动态创建组件"><a href="#动态创建组件" class="headerlink" title="动态创建组件"></a>动态创建组件</h2><p>想想应用的路由，一般配置路由地址的时候都会给这个地址配置一个入口组件，当匹配到这个路由地址的时候就在指定的地方渲染这个组件，动态创建组件类似，在最页面未接收到用户行为的时候，我不知道页面中这块区域应该渲染那个组件，当页面加载时根据数据库设置或者用户的操作行为才能确定最终要渲染的组件，这时候就要用代码动态创建组件把目标组件渲染到正确的地方。</p>
<p><img src="/img/angular_portals/elem1.jpg"></p>
<h2 id="使用-Angular-API-动态创建组件"><a href="#使用-Angular-API-动态创建组件" class="headerlink" title="使用 Angular API 动态创建组件"></a>使用 Angular API 动态创建组件</h2><p>该路由的入口组件是 PortalsEntryConponent 组件，如上面截图所示右侧有一块虚线边框的区域，里面具体的渲染组件不确定。</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>先在视图模板中定义一个占位的区域，动态组件就要渲染在这个位置，起一个名称 <code>#virtualContainer</code> 文件 portals-entry.component.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;portals-outlet&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ng-container</span> #<span class="attr">virtualContainer</span>&gt;</span> <span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>通过 ViewChild 取到这个 container 对应的逻辑容器 文件 portals-entry.component.ts</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;virtualContainer&#x27;</span>, &#123; <span class="attr">read</span>: ViewContainerRef &#125;)</span><br><span class="line">virtualContainer: ViewContainerRef;</span><br></pre></td></tr></table></figure>

<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>处理单击事件，单击按钮时动态创建一个组件，portals-entry.component.ts 完整逻辑</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TaskDetailComponent &#125; <span class="keyword">from</span> <span class="string">&quot;../task/task-detail/task-detail.component&quot;</span>;</span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">&quot;app-portals-entry&quot;</span>,</span><br><span class="line">  templateUrl: <span class="string">&quot;./portals-entry.component.html&quot;</span>,</span><br><span class="line">  styleUrls: [<span class="string">&quot;./portals-entry.component.scss&quot;</span>],</span><br><span class="line">  providers: [],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PortalsEntryComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  <span class="meta">@ViewChild</span>(<span class="string">&quot;virtualContainer&quot;</span>, &#123; <span class="attr">read</span>: ViewContainerRef &#125;)</span><br><span class="line">  virtualContainer: ViewContainerRef;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> dynamicComponentService: DynamicComponentService,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> componentFactoryResolver: ComponentFactoryResolver,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> injector: Injector</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">openTask</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> task = <span class="keyword">new</span> TaskEntity();</span><br><span class="line">    task.id = <span class="string">&quot;1000&quot;</span>;</span><br><span class="line">    task.name = <span class="string">&quot;写一篇关于Portals的文章&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> componentFactory = <span class="built_in">this</span>.componentFactoryResolver.resolveComponentFactory(</span><br><span class="line">      TaskDetailComponent</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> componentRef = <span class="built_in">this</span>.virtualContainer.createComponent&lt;TaskDetailComponent&gt;(</span><br><span class="line">      componentFactory,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      <span class="built_in">this</span>.virtualContainer.injector</span><br><span class="line">    );</span><br><span class="line">    (componentRef.instance <span class="keyword">as</span> TaskDetailComponent).task = task; <span class="comment">// 传递参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ul>
<li>openTask()方法绑定到模板中按钮的单击事件</li>
<li>导入要动态创建的组件 TaskDetailComponent</li>
<li>constructor 注入 injector、componentFactoryResolver 动态创建组件需要的对象，只有在组件上下文中才可以拿到这些实例对象</li>
<li>使用 api 创建组件，现根据组件类型创建一个 ComponentFactory 对象，然后调用 viewContainer 的 createComponent 创建组件</li>
<li>使用 componentRef.instance 获取创建的组件实例，这里用来设置组件的 task 属性值</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>ViewContainerRef 除了 createComponent 方法外还有一个 createEmbeddedView 方法，用于创建模板</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;customTemplate&#x27;</span>)</span><br><span class="line">customTemplate: TemplateRef&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"><span class="built_in">this</span>.virtualContainer.createEmbeddedView(<span class="built_in">this</span>.customTemplate, &#123; <span class="attr">name</span>: <span class="string">&#x27;pubuzhixing&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>createEmbeddedView 方法的第二个参数，用于指定模板的上下文参数，看下模板定义及如何使用参数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> #<span class="attr">customTemplate</span> <span class="attr">let-name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>自定义模板，传入参数name：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外还可以通过 ngTemplateOutlet 直接插入内嵌视图模板，通过 ngTemplateOutletContext 指定模板的上下文参数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ng-container</span><br><span class="line">  [ngTemplateOutlet]=&quot;customTemplate&quot;</span><br><span class="line">  [ngTemplateOutletContext]=&quot;&#123; name:&#x27;pubuzhixing&#x27; &#125;&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>分析下 Angular 动态创建组件/内嵌视图的 API，动态创建组件首先需要一个被创建的组件定义或模板声明，另外需要 Angular 上下文的环境来提供这个组件渲染在那里以及这个组件的依赖从那获取，viewContainerRef 是动态组件的插入位置并且提供组件的逻辑范围，此外还需要单独传入依赖注入器 injector，示例直接使用逻辑容器的 injector，是不是很好理解。</p>
<h2 id="CDK-Portal-文档介绍"><a href="#CDK-Portal-文档介绍" class="headerlink" title="CDK Portal 文档介绍"></a>CDK Portal 文档介绍</h2><p>这里先对 Portal 相关的内容做一个简单的说明，后面会有两个使用示例，本来这块内容准备放到最后的，最终还是决定放在前面，可以先对 Portals 有一个简单的了解，如果其中有翻译不准确请见谅，官方文档地址：<a target="_blank" rel="noopener" href="https://material.angular.io/cdk">https://material.angular.io/cdk</a></p>
<p>portals 提供渲染动态内容到应用的可伸缩的实现，其实就是封装了 Angular 动态创建组件的过程</p>
<h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>这个 Portal 指是能动态渲染一个指定位置的 UI 块 到页面中的一个 open slot 。 UI 块 指需要被动态渲染的内容，可以是一个组件或者是一个模板，而 open slot 是一个叫做 PortalOutlet 的开放的占位区域。 Portals 和 PortalOutlets 是其它概念中的低级的构造块，像 overlays 就是在它基础上构建的</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Portal&lt;T&gt; 包括动态组件的抽象类，可以是TemplatePortal（模板）或者ComponentPortal（组件）</span><br></pre></td></tr></table></figure>

<p><img src="/img/angular_portals/elem2.jpg"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PortalOutlet 动态组件的宿主</span><br></pre></td></tr></table></figure>

<p><img src="/img/angular_portals/elem3.jpg"></p>
<h3 id="代码片段说明"><a href="#代码片段说明" class="headerlink" title="代码片段说明"></a>代码片段说明</h3><p>CdkPortal</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">cdkPortal</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The content of this template is captured by the portal.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- OR --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过下面的结构指令语法可以得到同样的结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">cdkPortal</span>&gt;</span>The content of this template is captured by the portal.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以通过 ViewChild、ViewChildren 获取到该 Portal，类型应该是 CdkPortal，如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板中的Portal</span></span><br><span class="line"><span class="meta">@ViewChild</span>(CdkPortal) templateCDKPortal: TemplatePortal&lt;<span class="built_in">any</span>&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>ComponentPortal</strong> 组件类型的 Portal，需要当前组件在 NgModule 的 entryComponents 中配置才能动态创建该组件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.userSettingsPortal = <span class="keyword">new</span> ComponentPortal(UserSettingsComponent);</span><br></pre></td></tr></table></figure>

<p><strong>CdkPortalOutlet</strong> 使用指令可以把 portal outlet 添加到一个 ng-template，cdkPortalOutlet 把当前元素指定为 PortalOutlet，下面代码把 userSettingsPortal 绑到此 portal-outlet 上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Attaches the `userSettingsPortal` from the previous example. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> [<span class="attr">cdkPortalOutlet</span>]=<span class="string">&quot;userSettingsPortal&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Portals-使用示例"><a href="#Portals-使用示例" class="headerlink" title="Portals 使用示例"></a>Portals 使用示例</h2><p>这里首先使用新的 api 完成和最上面示例一样的需求，在同样的位置动态渲染 TaskDetailComponent 组件。</p>
<h3 id="第一步-1"><a href="#第一步-1" class="headerlink" title="第一步"></a>第一步</h3><p>同样是设置一个宿主元素用于渲染动态组件，可以使用指令 cdkPortalOutlet 挂载一个 PortalOutlet 在这个 ng-container 元素上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;portals-outlet&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ng-container</span> #<span class="attr">virtualContainer</span> <span class="attr">cdkPortalOutlet</span>&gt;</span> <span class="tag">&lt;/<span class="name">ng-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步-1"><a href="#第二步-1" class="headerlink" title="第二步"></a>第二步</h3><p>与 <strong>使用 Angular API 动态创建组件</strong> 一节使用同一个逻辑元素作为宿主，只不过这里的获取容器的类型是 CdkPortalOutlet，代码如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;virtualContainer&#x27;</span>, &#123; <span class="attr">read</span>: CdkPortalOutlet &#125;)</span><br><span class="line">virtualPotalOutlet: CdkPortalOutlet;</span><br></pre></td></tr></table></figure>

<h3 id="第三步-1"><a href="#第三步-1" class="headerlink" title="第三步"></a>第三步</h3><p>创建一个 ComponentPortal 类型的 Portal，并且将它附加上面获取的宿主 virtualPotalOutlet 上，代码如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">portalOpenTask</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.virtualPotalOutlet.detach();</span><br><span class="line">    <span class="keyword">const</span> taskDetailCompoentPortal = <span class="keyword">new</span> ComponentPortal&lt;TaskDetailComponent&gt;(</span><br><span class="line">        TaskDetailComponent</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> ref = <span class="built_in">this</span>.virtualPotalOutlet.attach(taskDetailCompoentPortal);</span><br><span class="line">    <span class="comment">// 此处同样可以 通过ref.instance传递task参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>这里是使用 ComponentPortal 的示例实现动态创建组件，Portal 还有一个子类 TemplatePortal 是针对模板实现的，上节 CDK Portal 官方文档介绍 中有介绍，这里就不在赘述了。总之使用 Portals 可以很大程度上简化代码逻辑。</p>
<h2 id="Portals-源码分析"><a href="#Portals-源码分析" class="headerlink" title="Portals 源码分析"></a>Portals 源码分析</h2><p>上面只是使用 Portal 的最简单用法，下面讨论下它的源码实现，以便更好的理解</p>
<h3 id="ComponentPortal"><a href="#ComponentPortal" class="headerlink" title="ComponentPortal"></a>ComponentPortal</h3><p>首先我们先看一下 ComponentPortal 类的创建，上面的例子只是指定了一个组件类型作为参数，其实它还有别的参数可以配置，先看下 ComponentPortal 的构造函数定义</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentPortal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Portal</span>&lt;<span class="title">ComponentRef</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    component: ComponentType&lt;T&gt;,</span></span><br><span class="line"><span class="params">    viewContainerRef?: ViewContainerRef | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    injector?: Injector | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    componentFactoryResolver?: ComponentFactoryResolver | <span class="literal">null</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.component = component;</span><br><span class="line">    <span class="built_in">this</span>.viewContainerRef = viewContainerRef;</span><br><span class="line">    <span class="built_in">this</span>.injector = injector;</span><br><span class="line">    <span class="built_in">this</span>.componentFactoryResolver = componentFactoryResolver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ComponentPortal 构造函数的另外两个参数 viewContainerRef 和 injector viewContainerRef 参数非必填默认附到 PortalOutlet 上，如果传入 viewContainerRef 参数，那么 ComponentPortal 就会附到该 viewContaierRef 上，而不是当前 PortalOutlet 所在的元素上。 injector 参数非必填，默认使用 PortalOutlet 所在的逻辑容器的 injector，如果传入 injector，那么动态创建的组件就使用传入的 injector 作为注入器。</p>
</blockquote>
<h3 id="BasePortalOutlet"><a href="#BasePortalOutlet" class="headerlink" title="BasePortalOutlet"></a>BasePortalOutlet</h3><p>BasePortalOutlet 提供了附加 ComponentPortal 和 TemplatePortal 的部分实现，我们看下 attach 方法的部分代码（仅仅展示部分逻辑）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Attaches a portal. */</span></span><br><span class="line">attach(portal: Portal&lt;<span class="built_in">any</span>&gt;): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!portal) &#123;</span><br><span class="line">        throwNullPortalError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (portal <span class="keyword">instanceof</span> ComponentPortal) &#123;</span><br><span class="line">        <span class="built_in">this</span>._attachedPortal = portal;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.attachComponentPortal(portal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (portal <span class="keyword">instanceof</span> TemplatePortal) &#123;</span><br><span class="line">        <span class="built_in">this</span>._attachedPortal = portal;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.attachTemplatePortal(portal);</span><br><span class="line">    &#125;</span><br><span class="line">    throwUnknownPortalTypeError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>attach 处理前先根据 Portal 的类型是确实是组件还是模板，然后再进行相应的处理，其实最终还是调用了 ViewContainerRef 的 createComponent 或者 createEmbeddedView 方法，对这块感兴趣可看查看源代码文件 portal-directives.ts。</p>
<h3 id="DomPortalOutlet"><a href="#DomPortalOutlet" class="headerlink" title="DomPortalOutlet"></a>DomPortalOutlet</h3><p>DomPortalOutlet 可以把一个 Portal 插入到一个 Angular 应用上下文之外的 DOM 中，想想我们前面的例子，无论自己实现还是使用 CdkPortalOutlet 都是把一个模板或者组件插入到一个 Angular 上下文中的宿主 ViewContainerRef 中，而 DomPortalOutlet 就是 脱离 Angular 上下文 的宿主，可以把 Portal 渲染到任意 dom 中，我们常常有这种需求，比如弹出的模态框、Select 浮层。</p>
<p>在 cdk 中 Overlay 用到了 DomPortalOutlet，然后 material ui 的 MatMenu 也用到了 DomPortalOutlet，MatMenu 比较容易理解，简单看下它是如何创建和使用的 DomPortalOutle（查看全部）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>._outlet) &#123;</span><br><span class="line">  <span class="built_in">this</span>._outlet = <span class="keyword">new</span> DomPortalOutlet(</span><br><span class="line">    <span class="built_in">this</span>._document.createElement(<span class="string">&quot;div&quot;</span>),</span><br><span class="line">    <span class="built_in">this</span>._componentFactoryResolver,</span><br><span class="line">    <span class="built_in">this</span>._appRef,</span><br><span class="line">    <span class="built_in">this</span>._injector</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element: HTMLElement = <span class="built_in">this</span>._template.elementRef.nativeElement;</span><br><span class="line">element.parentNode!.insertBefore(<span class="built_in">this</span>._outlet.outletElement, element);</span><br><span class="line"><span class="built_in">this</span>._portal.attach(<span class="built_in">this</span>._outlet, context);</span><br></pre></td></tr></table></figure>

<p>上面的代码先创建了 DomPortalOutlet 类型的对象_outlet，DomPortalOutlet 是一个 DOM 宿主它不在 Angular 的任何一个 ViewContainerRef 中，现在看下它的四个构造函数参数</p>
<p><img src="/img/angular_portals/elem4.jpg"></p>
<blockquote>
<p>说明：这节讲的 脱离 Angular 上下文 是不太准确定，任何模板或者组件都不能脱离 Angular 的运行环境，这里应该是脱离了实际渲染的 Component Tree，单独渲染到指定 dom 中。</p>
</blockquote>
<h2 id="复杂示例"><a href="#复杂示例" class="headerlink" title="复杂示例"></a>复杂示例</h2><p>为 ComponentPortal 传入 PortalInjector 对象，PortalInjector 实例对象配置一个其它业务组件的 injector 并且配置 tokens，下面简单说明下逻辑结构，有兴趣的可看完整示例。</p>
<h3 id="业务组件-TaskListComponent"><a href="#业务组件-TaskListComponent" class="headerlink" title="业务组件 TaskListComponent"></a>业务组件 TaskListComponent</h3><p>文件 task-list.component.ts</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;，</span><br><span class="line">  selector: <span class="string">&#x27;app-task-list&#x27;</span>,</span><br><span class="line">  templateUrl: <span class="string">&#x27;./task-list.component.html&#x27;</span>,</span><br><span class="line">  styleUrls: [<span class="string">&#x27;./task-list.component.scss&#x27;</span>],</span><br><span class="line">  providers: [TaskListService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskListComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> taskListService: TaskListService</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件级提供商配置了 TaskListService</p>
<h3 id="定义-TaskListService"><a href="#定义-TaskListService" class="headerlink" title="定义 TaskListService"></a>定义 TaskListService</h3><p>用于获取任务列表数据，并保存在属性 tasks 中</p>
<h3 id="TaskListComponent-模板"><a href="#TaskListComponent-模板" class="headerlink" title="TaskListComponent 模板"></a>TaskListComponent 模板</h3><p>在模板中直接绑定 taskListService.tasks 属性数据</p>
<h3 id="修改父组件-PortalsEntryComponent"><a href="#修改父组件-PortalsEntryComponent" class="headerlink" title="修改父组件 PortalsEntryComponent"></a>修改父组件 PortalsEntryComponent</h3><p>因为 PortalOutlet 是在父组件中，所以单击任务列表创建动态组件的逻辑是从父组件响应的 portals-entry.component.ts</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;taskListContainer&#x27;</span>, &#123; <span class="attr">read</span>: TaskListComponent &#125;)</span><br><span class="line">taskListComponent: TaskListComponent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ngOnInit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.taskListComponent.openTask = <span class="function"><span class="params">task</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.portalCreatTaskModel(task);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">portalCreatTaskModel</span>(<span class="params">task: TaskEntity</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.virtualPotalOutlet.detach();</span><br><span class="line">    <span class="keyword">const</span> customerTokens = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    customerTokens.set(TaskEntity, task);</span><br><span class="line">    <span class="keyword">const</span> portalInjector = <span class="keyword">new</span> PortalInjector(</span><br><span class="line">      <span class="built_in">this</span>.taskListViewContainerRef.injector,</span><br><span class="line">      customerTokens</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> taskModelCompoentPortal = <span class="keyword">new</span> ComponentPortal&lt;TaskModelComponent&gt;(</span><br><span class="line">      TaskModelComponent,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      portalInjector</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">this</span>.virtualPotalOutlet.attach(taskModelCompoentPortal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给 ComponentPortal 的构造函数传递了 PortalInjector 类型的参数 portalInjector，PortalInjector 继承自 Injector</p>
<h3 id="PortalInjector-构造函数的两个参数"><a href="#PortalInjector-构造函数的两个参数" class="headerlink" title="PortalInjector 构造函数的两个参数"></a>PortalInjector 构造函数的两个参数</h3><ol>
<li>第一个参数是提供一个基础的注入器 injector，这里使用了 taskListViewContainerRef.injector，taskListViewContainerRef 就是业务 TaskListComponent 组件的 viewContainerRef</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;taskListContainer&#x27;</span>, &#123; <span class="attr">read</span>: ViewContainerRef &#125;)</span><br><span class="line">taskListViewContainerRef: ViewContainerRef;</span><br></pre></td></tr></table></figure>

<p>也就是新的组件的注入器来自于 TaskListComponent</p>
<ol start="2">
<li>第二个参数是提供一个 tokens，类型是 WeakMap，其实就是 key/value 的键值对，只不过它的 key 只能是引用类型的对象，这里把类型 TaskEntity 作为 key，当前选中的实例对象作为 value，就可以实现对象的传入，使用 set 方法 <code>customerTokens.set(TaskEntity, task)</code>。</li>
</ol>
<h3 id="新的任务详情组件-TaskModelComponent"><a href="#新的任务详情组件-TaskModelComponent" class="headerlink" title="新的任务详情组件 TaskModelComponent"></a>新的任务详情组件 TaskModelComponent</h3><p>task-model.component.ts</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> task: TaskEntity,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> taskListService: TaskListService</span></span><br><span class="line"><span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>没错，是通过注入器注入的方式获取 TaskEntity 实例和服务 TaskListService 的实例 taskListService。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个例子相对复杂，只是想说明可以给动态创建的组件传入特定的 injector。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Angular 动态创建组件之 Portals</p><p><a href="https://kainonly.com/front-end/angular_portals/">https://kainonly.com/front-end/angular_portals/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Kain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-31</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-31</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/angular/">angular</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/backend/php_session/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">PHP Session 分布</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/front-end/angular_content/"><span class="level-item">Angular 之 ng-content</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://kainonly.com/front-end/angular_portals/';
            this.page.identifier = 'front-end/angular_portals/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'kains-note' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#动态创建组件"><span class="level-left"><span class="level-item">动态创建组件</span></span></a></li><li><a class="level is-mobile" href="#使用-Angular-API-动态创建组件"><span class="level-left"><span class="level-item">使用 Angular API 动态创建组件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第一步"><span class="level-left"><span class="level-item">第一步</span></span></a></li><li><a class="level is-mobile" href="#第二步"><span class="level-left"><span class="level-item">第二步</span></span></a></li><li><a class="level is-mobile" href="#第三步"><span class="level-left"><span class="level-item">第三步</span></span></a></li><li><a class="level is-mobile" href="#代码说明"><span class="level-left"><span class="level-item">代码说明</span></span></a></li><li><a class="level is-mobile" href="#其它"><span class="level-left"><span class="level-item">其它</span></span></a></li><li><a class="level is-mobile" href="#小结"><span class="level-left"><span class="level-item">小结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CDK-Portal-文档介绍"><span class="level-left"><span class="level-item">CDK Portal 文档介绍</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Portals"><span class="level-left"><span class="level-item">Portals</span></span></a></li><li><a class="level is-mobile" href="#代码片段说明"><span class="level-left"><span class="level-item">代码片段说明</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Portals-使用示例"><span class="level-left"><span class="level-item">Portals 使用示例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第一步-1"><span class="level-left"><span class="level-item">第一步</span></span></a></li><li><a class="level is-mobile" href="#第二步-1"><span class="level-left"><span class="level-item">第二步</span></span></a></li><li><a class="level is-mobile" href="#第三步-1"><span class="level-left"><span class="level-item">第三步</span></span></a></li><li><a class="level is-mobile" href="#小结-1"><span class="level-left"><span class="level-item">小结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Portals-源码分析"><span class="level-left"><span class="level-item">Portals 源码分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ComponentPortal"><span class="level-left"><span class="level-item">ComponentPortal</span></span></a></li><li><a class="level is-mobile" href="#BasePortalOutlet"><span class="level-left"><span class="level-item">BasePortalOutlet</span></span></a></li><li><a class="level is-mobile" href="#DomPortalOutlet"><span class="level-left"><span class="level-item">DomPortalOutlet</span></span></a></li></ul></li><li><a class="level is-mobile" href="#复杂示例"><span class="level-left"><span class="level-item">复杂示例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#业务组件-TaskListComponent"><span class="level-left"><span class="level-item">业务组件 TaskListComponent</span></span></a></li><li><a class="level is-mobile" href="#定义-TaskListService"><span class="level-left"><span class="level-item">定义 TaskListService</span></span></a></li><li><a class="level is-mobile" href="#TaskListComponent-模板"><span class="level-left"><span class="level-item">TaskListComponent 模板</span></span></a></li><li><a class="level is-mobile" href="#修改父组件-PortalsEntryComponent"><span class="level-left"><span class="level-item">修改父组件 PortalsEntryComponent</span></span></a></li><li><a class="level is-mobile" href="#PortalInjector-构造函数的两个参数"><span class="level-left"><span class="level-item">PortalInjector 构造函数的两个参数</span></span></a></li><li><a class="level is-mobile" href="#新的任务详情组件-TaskModelComponent"><span class="level-left"><span class="level-item">新的任务详情组件 TaskModelComponent</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">前端技术</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">后端技术</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%89%8B%E8%AE%B0/"><span class="level-start"><span class="level-item">手记</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">运维技术</span></span><span class="level-end"><span class="level-item tag">35</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/certbot/"><span class="tag">certbot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debian/"><span class="tag">debian</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debian-ubuntu/"><span class="tag">debian ubuntu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/electron/"><span class="tag">electron</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/emqx/"><span class="tag">emqx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lumen/"><span class="tag">lumen</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nats/"><span class="tag">nats</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openssl/"><span class="tag">openssl</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgsql/"><span class="tag">postgsql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/satis/"><span class="tag">satis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/window/"><span class="tag">window</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Kain&#039;s Notes" height="28"></a><p class="is-size-7"><span>&copy; 2021 Kain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7"><a href="https://beian.miit.gov.cn" target="_blank">琼ICP备18004473号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/kainonly"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>