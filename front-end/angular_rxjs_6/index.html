<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>RxJS 源码解析(六): Scheduler - Kain&#039;s Notes</title><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kainonly.com/front-end/angular_rxjs_6/"},"headline":"RxJS 源码解析(六): Scheduler","image":[],"datePublished":"2021-06-07T06:57:37.104Z","dateModified":"2021-06-07T07:44:09.501Z","author":{"@type":"Person","name":"Kain"},"description":"在这之前，我一直都没有讲过 Scheduler 的作用，那么本章就开始讲解 Scheduler 的设计思路和基本结构。RxJS 的存在是为了处理异步 IO，而异步 IO 所包含的一系列 API 肯定也是要经过进一步的封装才能让 RxJS 中的异步操作使用。  可以看到，它主要还是根据 JS 的所能够提供的异步能力来设计这些基本结构。  AsyncScheduler 异步调度器，使用 setInte"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/vs2015.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-J0NVPEBDTM" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-J0NVPEBDTM');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Kain&#039;s Notes" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.yuque.com/kainonly">语雀</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/archives">归档</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/kainonly"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-07T06:57:37.104Z" title="2021/6/7 下午2:57:37">2021-06-07</time>发表</span><span class="level-item"><time dateTime="2021-06-07T07:44:09.501Z" title="2021/6/7 下午3:44:09">2021-06-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a></span><span class="level-item">20 分钟读完 (大约2978个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">RxJS 源码解析(六): Scheduler</h1><div class="content"><p>在这之前，我一直都没有讲过 Scheduler 的作用，那么本章就开始讲解 Scheduler 的设计思路和基本结构。RxJS 的存在是为了处理异步 IO，而异步 IO 所包含的一系列 API 肯定也是要经过进一步的封装才能让 RxJS 中的异步操作使用。</p>
<p><img src="/img/angular_rxjs_6/elem1.webp"></p>
<p>可以看到，它主要还是根据 JS 的所能够提供的异步能力来设计这些基本结构。</p>
<ul>
<li>AsyncScheduler 异步调度器，使用 <code>setInterval</code> 实现。</li>
<li>QueueScheduler 队列异步调度器，继承了 <code>AsyncScheduler</code>，但是 <code>QueueAction</code> 是一种链式结构，使得调度以迭代器的形式进行。</li>
<li>AnimationFrameScheduler 使用 <code>reqeustAnimationFrame</code> 实现了帧调度器。</li>
<li>AsapScheduler 使用 <code>Promise.resolve().then()</code> 实现的微任务调度器。</li>
</ul>
<p>作者：zcx<br>链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vG0aaQmDy7Cqfv0CwJ_d0Q">https://mp.weixin.qq.com/s/vG0aaQmDy7Cqfv0CwJ_d0Q</a></p>
<span id="more"></span>

<h2 id="SchedulerLike-、-Scheduler-amp-Action"><a href="#SchedulerLike-、-Scheduler-amp-Action" class="headerlink" title="SchedulerLike 、 Scheduler &amp; Action"></a>SchedulerLike 、 Scheduler &amp; Action</h2><p>首先，SchedulerLike 提供了以下两个接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SchedulerLike &#123;</span><br><span class="line">  <span class="comment">// 标记当前时间</span></span><br><span class="line">  now(): <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开启调度的基础接口</span></span><br><span class="line">  schedule&lt;T&gt;(</span><br><span class="line">    work: <span class="function">(<span class="params"><span class="built_in">this</span>: SchedulerAction&lt;T&gt;, state?: T</span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">    delay?: <span class="built_in">number</span>,</span><br><span class="line">    state?: T</span><br><span class="line">  ): Subscription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scheduler 则实现了这些接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> <span class="title">implements</span> <span class="title">SchedulerLike</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前时间戳</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> now: <span class="function">() =&gt;</span> <span class="built_in">number</span> = <span class="function">() =&gt;</span> <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> SchedulerAction: <span class="keyword">typeof</span> Action,</span></span><br><span class="line"><span class="params">    now: () =&gt; <span class="built_in">number</span> = Scheduler.now</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.now = now;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> now: <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 直接调用 action 的 schedule</span></span><br><span class="line">  <span class="keyword">public</span> schedule&lt;T&gt;(</span><br><span class="line">    work: <span class="function">(<span class="params"><span class="built_in">this</span>: SchedulerAction&lt;T&gt;, state?: T</span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">    delay: <span class="built_in">number</span> = <span class="number">0</span>,</span><br><span class="line">    state?: T</span><br><span class="line">  ): Subscription &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.SchedulerAction&lt;T&gt;(<span class="built_in">this</span>, work).schedule(state, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scheduler 为后续的继承它的调度器定义了创建方式，通过传入一个 Action 工厂，使得内部可以构造特定的 Action 。而 Action 继承了 Subscription，意味着 Action 实际上是一种的订阅器。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    scheduler: Scheduler,</span></span><br><span class="line"><span class="params">    work: (<span class="built_in">this</span>: SchedulerAction&lt;T&gt;, state?: T) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Action 开始调度</span></span><br><span class="line">  <span class="keyword">public</span> schedule(state?: T, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): Subscription &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的设计是一种名为 <code>Template Method</code> 的设计模式，这种方法有效地约束了后续的不同的 Scheduler 的实现。</p>
<blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。它使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<h2 id="异步调度器"><a href="#异步调度器" class="headerlink" title="异步调度器"></a>异步调度器</h2><p>先来了解一下 Scheduler 的子类 AsyncScheduler，余下所有的 Scheduler 都会继承它。在这里，先不急着进行源码分析，我们需要先为了弄清楚调度器的运行原理，了解调度器是如何对异步 API 进行封装的。</p>
<p>首先，调度器本身也是基于观察者模式来进行设计，但是它又独立于 Rxjs 的 Observable。一般来说， AsyncScheduler 是这样调用的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scheduler = AsyncScheduler(AsyncAction);</span><br><span class="line"><span class="keyword">const</span> subscription = <span class="keyword">async</span>.schedule(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">counter</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(counter);</span><br><span class="line">    <span class="comment">// this 绑定了 AsyncAction</span></span><br><span class="line">    <span class="built_in">this</span>.schedule(counter + <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1000</span>,</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscription.unsubscribe();</span></span><br></pre></td></tr></table></figure>

<p>它的调用栈是这样的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AsyncScheduler.schedule;</span><br><span class="line">AsyncAction.schedule;</span><br><span class="line">AsyncAction.requestAsyncId;</span><br><span class="line">listOnTimeout; <span class="comment">// 原生事件</span></span><br><span class="line">processTimers; <span class="comment">// 原生事件</span></span><br><span class="line">AsyncScheduler.flush;</span><br><span class="line">AsyncAction.execute;</span><br><span class="line">AsyncAction._execute;</span><br><span class="line">AsyncAction.work;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncAction-schedule"><a href="#AsyncAction-schedule" class="headerlink" title="AsyncAction.schedule"></a>AsyncAction.schedule</h3><p>跟着调用栈分析源码来溯源，在 AsyncScheduler 的 <code>schedule</code> 方法中，它先构造了 AsyncAction ，然后调用它的 <code>schedule</code> 。在这个方法中，实际上是对 Action 的内部状态进行更新，所以此处关注的地方就是在于 <code>schedule</code> 如何触发异步 API。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncAction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> scheduler: AsyncScheduler,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> work: (<span class="built_in">this</span>: SchedulerAction&lt;T&gt;, state?: T) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(scheduler, work);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> schedule(state?: T, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): Subscription &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.closed) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.state = state;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">this</span>.id;</span><br><span class="line">    <span class="keyword">const</span> scheduler = <span class="built_in">this</span>.scheduler;</span><br><span class="line">    <span class="comment">// 需要对相应的异步 API 进行取消操作</span></span><br><span class="line">    <span class="keyword">if</span> (id != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = <span class="built_in">this</span>.recycleAsyncId(scheduler, id, delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.pending = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.delay = delay;</span><br><span class="line">    <span class="comment">// 重新配置异步 API</span></span><br><span class="line">    <span class="built_in">this</span>.id = <span class="built_in">this</span>.id || <span class="built_in">this</span>.requestAsyncId(scheduler, <span class="built_in">this</span>.id, delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，从 scheduler 传入的回调函数最终会被 Action 持有，所以调用栈最终执行的 <code>work</code> 实际上就是回调函数。</p>
<h3 id="AsyncAction-requestAsyncId"><a href="#AsyncAction-requestAsyncId" class="headerlink" title="AsyncAction.requestAsyncId"></a>AsyncAction.requestAsyncId</h3><p><code>requestAsyncId</code> 是调用异步 API 的方法，这个方法在 AsyncAction 最终触发了 <code>setInterval</code> 这一异步 API。那么实际上，根据 Template Method 的设计，所有继承 AsyncAction 的 Action 都会通过这个方法实现相对应的异步 API 。</p>
<p>至于 AsyncAction 为什么会使用 <code>setInterval</code> 而不是 <code>setTimeout</code>，源代码里是这样说明的。</p>
<blockquote>
<p>Actions only execute once by default, unless rescheduled from within the scheduled callback. This allows us to implement single and repeat actions via the same code path, without adding API surface area, as well as mimic traditional recursion but across asynchronous boundaries. However, JS runtimes and timers distinguish between intervals achieved by serial setTimeout calls vs. a single setInterval call. An interval of serial setTimeout calls can be individufenally delayed, which delays scheduling the next setTimeout, and so on. setInterval attempts to guarantee the interval callback will be invoked more precisely to the interval period, regardless of load. Therefore, we use setInterval to schedule single and repeat actions. If the action reschedules itself with the same delay, the interval is not canceled. If the action doesn’t reschedule, or reschedules with a different delay, the interval will be canceled after scheduled callback execution.</p>
</blockquote>
<blockquote>
<p>对于某一个 Action 来说，除非它在调度的回调中被重新调度，那么它默认只会执行一次。这样的方式可以使得我们通过统一的代码实现调度单一或重复的 Actions，而无需添加 API，并且可以模仿传统递归来扩展异步。然而， JS 的运行时或者计时器分别通过串行的 setTimout 或者是单个 setInterval 来获取调用的定时器。串行的 setTimout 定时器可以单独延迟，这样做会延迟 c 下一个 setTimout 的调度，以此类推。而 setInterval 则不管程序运行的负载如何，它总是尝试去确保每一次定时器的回调更加精准的安排到合适的间隔时间。因此，我们使用 setInterval 来安排单一或重复的 Actions，如果 action 以相同的时延调度本身，那么当前定时器不会被取消。如果 action 只没有重新调度或者以不同的时延重新调度，则安排的回调执行后，改定时器会被取消。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncAction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> requestAsyncId(</span><br><span class="line">    scheduler: AsyncScheduler,</span><br><span class="line">    id?: <span class="built_in">any</span>,</span><br><span class="line">    delay: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">  ): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="comment">// 绑定 scheduler，并且把当前的 AsyncAction 当作参数传入。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setInterval</span>(scheduler.flush.bind(scheduler, <span class="built_in">this</span>), delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncScheduler-flush"><a href="#AsyncScheduler-flush" class="headerlink" title="AsyncScheduler.flush"></a>AsyncScheduler.flush</h3><p>所以，在 AsyncScheduler 中，新增的 <code>flush</code> 方法实际上是为 setInterval 服务的，它作为异步 API 的回调函数，主要步骤如下。</p>
<ul>
<li>如果存在运行中的 Action ，它会保存所用调用它的 Action。</li>
<li>如果不存在运行中的 Action，它会执行所有调用队列中的 Action.execute</li>
<li>处理 Action.execute 的运行错误。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> flush(action: AsyncAction&lt;<span class="built_in">any</span>&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; actions &#125; = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">      <span class="comment">// 使用了一个队列保存所有输入的 Actions</span></span><br><span class="line">      actions.push(action);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> error: <span class="built_in">any</span>;</span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 默认 action 也是队列中的一员</span></span><br><span class="line">    <span class="comment">// 将所有队列中的 Action 进行调用。</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((error = action.execute(action.state, action.delay))) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((action = actions.shift()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出现错误时，取消所有未运行 action 的订阅</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 注意，此处不会重复取消订阅，因为执行错误的Action会先退出队列，再执行循环。</span></span><br><span class="line">      <span class="keyword">while</span> ((action = actions.shift())) &#123;</span><br><span class="line">        action.unsubscribe();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncAction-execute"><a href="#AsyncAction-execute" class="headerlink" title="AsyncAction.execute"></a>AsyncAction.execute</h3><p>上述的 flush 调用了 action 的 execute 方法。该方法也是通过处理 action 的内部状态来获得执行结果，其中会调用 _execute 这一内部方法，这个内部方法主要作用是调用 AsyncAction.work ，并处理它出现的异常。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncAction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> execute(state: T, <span class="attr">delay</span>: <span class="built_in">number</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.closed) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;executing a cancelled action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取异常错误</span></span><br><span class="line">    <span class="keyword">const</span> error = <span class="built_in">this</span>._execute(state, delay);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.pending === <span class="literal">false</span> &amp;&amp; <span class="built_in">this</span>.id != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = <span class="built_in">this</span>.recycleAsyncId(<span class="built_in">this</span>.scheduler, <span class="built_in">this</span>.id, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> _execute(state: T, <span class="attr">delay</span>: <span class="built_in">number</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> errored: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> errorValue: <span class="built_in">any</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// work</span></span><br><span class="line">      <span class="built_in">this</span>.work(state);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      errored = <span class="literal">true</span>;</span><br><span class="line">      errorValue = (!!e &amp;&amp; e) || <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errored) &#123;</span><br><span class="line">      <span class="built_in">this</span>.unsubscribe();</span><br><span class="line">      <span class="keyword">return</span> errorValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncAction-recycleAsyncId"><a href="#AsyncAction-recycleAsyncId" class="headerlink" title="AsyncAction.recycleAsyncId"></a>AsyncAction.recycleAsyncId</h3><p>在分析到 Action.schedule 的时候，引用了源码内部的注释，其中有一句话很重要，那就是 “如果 action 以相同的时延调度本身，那么当前定时器不会被取消”，所以 recycleAsyncId 这个方法是需要处理这种情况。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncAction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> recycleAsyncId(</span><br><span class="line">    scheduler: AsyncScheduler,</span><br><span class="line">    id: <span class="built_in">any</span>,</span><br><span class="line">    delay: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">  ): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="comment">// this.delay === delay 处理了这种情况。</span></span><br><span class="line">    <span class="keyword">if</span> (delay !== <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.delay === delay &amp;&amp; <span class="built_in">this</span>.pending === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消当前的定时器</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运用-Template-Method"><a href="#运用-Template-Method" class="headerlink" title="运用 Template Method"></a>运用 Template Method</h3><p>AsyncScheduler 可以说已经把所有的地基都打好了，它可以直接拿来用，也可以继承并重写一些相关的接口把相应的异步 API 进行替换。</p>
<h2 id="队列调度器"><a href="#队列调度器" class="headerlink" title="队列调度器"></a>队列调度器</h2><p>队列调度器根据调用者传入的时延来决定使用同步方式的调度还是 setInterval 方式的调度。</p>
<p>QueueScheduler 单纯继承了 AsyncScheduler，其主要实现在 QueueAction 中，通过重写 <code>schedule</code> 、 <code>execute</code> 以及 <code>requestAsyncId</code> 等方法来实现这种功能。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueAction</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AsyncAction</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> schedule(state?: T, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): Subscription &#123;</span><br><span class="line">    <span class="comment">// delay &gt; 0 ，执行异步调度</span></span><br><span class="line">    <span class="keyword">if</span> (delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.schedule(state, delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.delay = delay;</span><br><span class="line">    <span class="built_in">this</span>.state = state;</span><br><span class="line">    <span class="comment">// 否则直接执行同步调度</span></span><br><span class="line">    <span class="built_in">this</span>.scheduler.flush(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> execute(state: T, <span class="attr">delay</span>: <span class="built_in">number</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="comment">// 根据传入的 delay 判断是否直接执行 work （同步执行）</span></span><br><span class="line">    <span class="keyword">return</span> delay &gt; <span class="number">0</span> || <span class="built_in">this</span>.closed</span><br><span class="line">      ? <span class="built_in">super</span>.execute(state, delay)</span><br><span class="line">      : <span class="built_in">this</span>._execute(state, delay);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> requestAsyncId(</span><br><span class="line">    scheduler: QueueScheduler,</span><br><span class="line">    id?: <span class="built_in">any</span>,</span><br><span class="line">    delay: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">  ): <span class="built_in">any</span> &#123;</span><br><span class="line">    <span class="comment">// 根据传入的 delay 以及本身的 delay 来决定是否使用异步</span></span><br><span class="line">    <span class="keyword">if</span> ((delay !== <span class="literal">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) || (delay === <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.delay &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.requestAsyncId(scheduler, id, delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// delay 为 0，直接同步调度</span></span><br><span class="line">    <span class="keyword">return</span> scheduler.flush(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="帧调度器-与-微任务调度器"><a href="#帧调度器-与-微任务调度器" class="headerlink" title="帧调度器 与 微任务调度器"></a>帧调度器 与 微任务调度器</h2><p>帧调度器根据调用者传入的时延来决定使用 <code>requestAnimationFrame</code> 还是 <code>setInterval</code> ，微任务调度器则是根据时延来决定使用 <code>Promise.reslove().then()</code> 还是 <code>setInterval</code>。</p>
<p>两者的调用类似，以至于可以结合起来分析。</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>它们的 action 方法均重写了 <code>requestAsyncId</code> 和 <code>recycleAsyncId</code>， 主要还是为了处理不同异步 API 。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> requestAsyncId(scheduler: AnimationFrameScheduler, id?: <span class="built_in">any</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (delay !== <span class="literal">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.requestAsyncId(scheduler, id, delay);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把当前action 加入到 actions 队列末端</span></span><br><span class="line">  scheduler.actions.push(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!scheduler.scheduled) &#123;</span><br><span class="line">      <span class="comment">// AsapAction 的情况</span></span><br><span class="line">      <span class="keyword">const</span> scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// AnimationFrameAction 的情况</span></span><br><span class="line">      <span class="keyword">const</span> scheduled = requestAnimationFrame(scheduler.flush.bind(scheduler, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">      scheduler.scheduled = scheduled;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> scheduler.scheduled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> recycleAsyncId(scheduler: AnimationFrameScheduler, id?: <span class="built_in">any</span>, <span class="attr">delay</span>: <span class="built_in">number</span> = <span class="number">0</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((delay !== <span class="literal">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) || (delay === <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.delay &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.recycleAsyncId(scheduler, id, delay);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (scheduler.actions.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// AsapAction</span></span><br><span class="line">    Immediate.clearImmediate(id);</span><br><span class="line">    <span class="comment">// AnimationFrameAction</span></span><br><span class="line">    cancelAnimationFrame(id);</span><br><span class="line"></span><br><span class="line">    scheduler.scheduled = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>它们的 flush，跟 AsyncScheduler 的 flush 实现思路差不多，依旧是轮询 actions 队列调用 action.execute ，只是它们的 flush 需要去处理额外的以下细节。</p>
<ul>
<li>action 传入可能为空。</li>
<li>处理 actions 的状态。</li>
<li>清空 scheduled，使得 scheduler 能够进行下一次调度。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export class AnimationFrameScheduler extends AsyncScheduler &#123;</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AsapScheduler</span> <span class="keyword">extends</span> <span class="title">AsyncScheduler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> flush(action?: AsyncAction&lt;<span class="built_in">any</span>&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.scheduled = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; actions &#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> error: <span class="built_in">any</span>;</span><br><span class="line">    <span class="keyword">let</span> index: <span class="built_in">number</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 此处顺序不能打乱，因为这样</span></span><br><span class="line">    action = action || actions.shift()!;</span><br><span class="line">    <span class="keyword">let</span> count: <span class="built_in">number</span> = actions.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((error = action.execute(action.state, action.delay))) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (++index &lt; count &amp;&amp; (action = actions.shift()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">while</span> (++index &lt; count &amp;&amp; (action = actions.shift())) &#123;</span><br><span class="line">        action.unsubscribe();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Immediate"><a href="#Immediate" class="headerlink" title="Immediate"></a>Immediate</h3><p>这里很有意思的一点， AsapScheduler 并没有直接通过 <code>Promise.reslove().then()</code> 来实现。而是把它封装成 <code>Immediate</code>，形成 <code>setImmediate</code> 和 <code>clearImmediate</code> 两个 API ，这样就使得微任务的调用其他的定时 API 无异。</p>
<p>内部实现是通过一个 Map 保存标记当前的是第几个微任务，这里并不直接保存 Promise，因为 Promise 执行完毕后就自行释放了，所以它需要的只是一个标记。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextHandle = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = (<span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve())();</span><br><span class="line"><span class="keyword">const</span> activeHandles: &#123; [key: <span class="built_in">number</span>]: <span class="built_in">any</span> &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAndClearHandle</span>(<span class="params">handle: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (handle <span class="keyword">in</span> activeHandles) &#123;</span><br><span class="line">    <span class="keyword">delete</span> activeHandles[handle];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Immediate = &#123;</span><br><span class="line">  setImmediate(cb: <span class="function">() =&gt;</span> <span class="built_in">void</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = nextHandle++;</span><br><span class="line">    activeHandles[handle] = <span class="literal">true</span>;</span><br><span class="line">    RESOLVED.then(<span class="function">() =&gt;</span> findAndClearHandle(handle) &amp;&amp; cb());</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  clearImmediate(handle: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    findAndClearHandle(handle);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇分析了 RxJS 的调度器相关的一系列内容，通过封装 JS 异步 API ，调度器实现相对应的异步功能，增强了 RxJS 对异步 IO 的掌控。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>RxJS 源码解析(六): Scheduler</p><p><a href="https://kainonly.com/front-end/angular_rxjs_6/">https://kainonly.com/front-end/angular_rxjs_6/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Kain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-06-07</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-06-07</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/angular/">angular</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/database/mysql_procedure_and_function/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL 创建存储过程与函数</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/front-end/angular_rxjs_5/"><span class="level-item">RxJS 源码解析(五): Operator III</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://kainonly.com/front-end/angular_rxjs_6/';
            this.page.identifier = 'front-end/angular_rxjs_6/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'kains-note' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#SchedulerLike-、-Scheduler-amp-Action"><span class="level-left"><span class="level-item">SchedulerLike 、 Scheduler &amp; Action</span></span></a></li><li><a class="level is-mobile" href="#异步调度器"><span class="level-left"><span class="level-item">异步调度器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#AsyncAction-schedule"><span class="level-left"><span class="level-item">AsyncAction.schedule</span></span></a></li><li><a class="level is-mobile" href="#AsyncAction-requestAsyncId"><span class="level-left"><span class="level-item">AsyncAction.requestAsyncId</span></span></a></li><li><a class="level is-mobile" href="#AsyncScheduler-flush"><span class="level-left"><span class="level-item">AsyncScheduler.flush</span></span></a></li><li><a class="level is-mobile" href="#AsyncAction-execute"><span class="level-left"><span class="level-item">AsyncAction.execute</span></span></a></li><li><a class="level is-mobile" href="#AsyncAction-recycleAsyncId"><span class="level-left"><span class="level-item">AsyncAction.recycleAsyncId</span></span></a></li><li><a class="level is-mobile" href="#运用-Template-Method"><span class="level-left"><span class="level-item">运用 Template Method</span></span></a></li></ul></li><li><a class="level is-mobile" href="#队列调度器"><span class="level-left"><span class="level-item">队列调度器</span></span></a></li><li><a class="level is-mobile" href="#帧调度器-与-微任务调度器"><span class="level-left"><span class="level-item">帧调度器 与 微任务调度器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Action"><span class="level-left"><span class="level-item">Action</span></span></a></li><li><a class="level is-mobile" href="#Scheduler"><span class="level-left"><span class="level-item">Scheduler</span></span></a></li><li><a class="level is-mobile" href="#Immediate"><span class="level-left"><span class="level-item">Immediate</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">前端技术</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">后端技术</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%89%8B%E8%AE%B0/"><span class="level-start"><span class="level-item">手记</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">运维技术</span></span><span class="level-end"><span class="level-item tag">35</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/certbot/"><span class="tag">certbot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debian/"><span class="tag">debian</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debian-ubuntu/"><span class="tag">debian ubuntu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/electron/"><span class="tag">electron</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/emqx/"><span class="tag">emqx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lumen/"><span class="tag">lumen</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nats/"><span class="tag">nats</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openssl/"><span class="tag">openssl</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgsql/"><span class="tag">postgsql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/satis/"><span class="tag">satis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/window/"><span class="tag">window</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Kain&#039;s Notes" height="28"></a><p class="is-size-7"><span>&copy; 2021 Kain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7"><a href="https://beian.miit.gov.cn" target="_blank">琼ICP备18004473号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/kainonly"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>