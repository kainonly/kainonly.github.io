<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>JS 项目中究竟应该使用 Object 还是 Map？ - Kain&#039;s Notes</title><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kainonly.com/front-end/js_object_or_map/"},"headline":"JS 项目中究竟应该使用 Object 还是 Map？","image":["https://kainonly.com/img/js_object_or_map/elem1.jpg","https://kainonly.com/img/js_object_or_map/elem2.jpg","https://kainonly.com/img/js_object_or_map/elem3.jpg","https://kainonly.com/img/js_object_or_map/elem4.jpg","https://kainonly.com/img/js_object_or_map/elem5.jpg","https://kainonly.com/img/js_object_or_map/elem6.jpg","https://kainonly.com/img/js_object_or_map/elem7.jpg","https://kainonly.com/img/js_object_or_map/elem8.jpg"],"datePublished":"2021-05-22T01:21:03.046Z","dateModified":"2021-05-26T00:51:20.459Z","author":{"@type":"Person","name":"Kain"},"description":"在日常的 JavaScript 项目中，我们最常用到的数据结构就是各种形式的键值对格式了（key-value pair）。在 JavaScript 中，除了最基础的 Object 是该格式外，ES6 新增的 Map 也同样是键值对格式。它们的用法在很多时候都十分接近。不知道有没有人和我一样纠结过该选择哪个去使用呢？在本菜最近的项目中，我又遇到了这样的烦恼，索性一不做二不休，去对比一下究竟该使用哪一"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/vs2015.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-J0NVPEBDTM" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-J0NVPEBDTM');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Kain&#039;s Notes" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" target="_blank" rel="noopener" href="https://www.yuque.com/kainonly">语雀</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/archives">归档</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/kainonly"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-22T01:21:03.046Z" title="2021/5/22 上午9:21:03">2021-05-22</time>发表</span><span class="level-item"><time dateTime="2021-05-26T00:51:20.459Z" title="2021/5/26 上午8:51:20">2021-05-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a></span><span class="level-item">20 分钟读完 (大约3072个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JS 项目中究竟应该使用 Object 还是 Map？</h1><div class="content"><p>在日常的 JavaScript 项目中，我们最常用到的数据结构就是各种形式的键值对格式了（key-value pair）。在 JavaScript 中，除了最基础的 Object 是该格式外，ES6 新增的 Map 也同样是键值对格式。它们的用法在很多时候都十分接近。不知道有没有人和我一样纠结过该选择哪个去使用呢？在本菜最近的项目中，我又遇到了这样的烦恼，索性一不做二不休，去对比一下究竟该使用哪一个。</p>
<p>本文将会探讨一下 Object 和 Map 的不同，从多个角度对比一下 Object 和 Map：</p>
<ul>
<li>用法的区别：在某些情况下的用法会截然不同</li>
<li>句法的区别：创建以及增删查改的句法区别</li>
<li>性能的区别：速度和内存占用情况</li>
</ul>
<p>希望读完本文的你可以在日后的项目中做出更为合适的选择。</p>
<p>作者：掘金开发者社区<br>链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358378689">https://zhuanlan.zhihu.com/p/358378689</a></p>
<span id="more"></span>

<h2 id="用法对比"><a href="#用法对比" class="headerlink" title="用法对比"></a>用法对比</h2><ul>
<li>对于 Object 而言，它键（key）的类型只能是字符串，数字或者 Symbol；而对于 Map 而言，它可以是任何类型。（包括 Date，Map，或者自定义对象）</li>
<li>Map 中的元素会保持其插入时的顺序；而 Object 则不会完全保持插入时的顺序，而是根据如下规则进行排序:<ul>
<li>非负整数会最先被列出，排序是从小到大的数字顺序</li>
<li>然后所有字符串，负整数，浮点数会被列出，顺序是根据插入的顺序</li>
<li>最后才会列出 Symbol，Symbol 也是根据插入的顺序进行排序的</li>
</ul>
</li>
<li>读取 Map 的长度很简单，只需要调用其 .size() 方法即可；而读取 Object 的长度则需要额外的计算： Object.keys(obj).length</li>
<li>Map 是可迭代对象，所以其中的键值对是可以通过 for of 循环或 .foreach() 方法来迭代的；而普通的对象键值对则默认是不可迭代的，只能通过 for in 循环来访问（或者使用 Object.keys(o)、Object.values(o)、Object.entries(o) 来取得表示键或值的数字）迭代时的顺序就是上面提到的顺序。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">o[<span class="built_in">Symbol</span>.iterator] !== <span class="literal">undefined</span>; <span class="comment">// false</span></span><br><span class="line">m[<span class="built_in">Symbol</span>.iterator] !== <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 Map 中新增键时，不会覆盖其原型上的键；而在 Object 中新增键时，则有可能覆盖其原型上的键:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[x, <span class="number">2</span>]]);</span><br><span class="line">o.x; <span class="comment">// 2，x = 1 被覆盖了</span></span><br><span class="line">m.x; <span class="comment">// 1，x = 1 不会被覆盖</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JSON 默认支持 Object 而不支持 Map。若想要通过 JSON 传输 Map 则需要使用到 .toJSON() 方法，然后在 JSON.parse() 中传入复原函数来将其复原。对于 JSON 这里就不具体展开了，有兴趣的朋友可以看一下这：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6931927132427780103#heading-5">JSON 的序列化和解析</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;x&quot;</span>, <span class="number">1</span>]]);</span><br><span class="line"><span class="keyword">const</span> o2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(o)); <span class="comment">// &#123;x:1&#125;</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(m)); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="句法对比"><a href="#句法对比" class="headerlink" title="句法对比"></a>句法对比</h2><h3 id="创建时的区别"><a href="#创建时的区别" class="headerlink" title="创建时的区别"></a>创建时的区别</h3><p><strong>Obejct</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;; <span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 调用构造函数</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>); <span class="comment">// 调用静态方法 Object.create</span></span><br></pre></td></tr></table></figure>

<p>对于 Object 来说，我们在 95%+ 的情况下都会选择对象字面量，它不仅写起来最简单，而且相较于下面的函数调用，在性能方面会更为高效。对于构建函数，可能唯一使用到的情况就是显式的封装一个基本类型；而 Object.create 可以为对象设定原型。</p>
<p><strong>Map</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 调用构造函数</span></span><br></pre></td></tr></table></figure>

<p>和 Object 不同，Map 没有那么多花里胡哨的创建方法，通常只会使用其构造函数来创建。</p>
<p>除了上述方法之外，我们也可以通过 Function.prototype.apply()、Function.prototype.call()、reflect.apply()、Reflect.construct() 方法来调用 Object 和 Map 的构造函数或者 Object.create() 方法，这里就不展开了。</p>
<h3 id="新增-读取-删除元素时的区别"><a href="#新增-读取-删除元素时的区别" class="headerlink" title="新增/读取/删除元素时的区别"></a>新增/读取/删除元素时的区别</h3><p><strong>Object</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">//新增/修改</span></span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line">o[<span class="string">&quot;y&quot;</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">o.x; <span class="comment">// 1</span></span><br><span class="line">o[<span class="string">&quot;y&quot;</span>]; <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//或者使用 ES2020 新增的条件属性访问表达式来读取</span></span><br><span class="line">o?.x; <span class="comment">// 1</span></span><br><span class="line">o?.[<span class="string">&quot;y&quot;</span>]; <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">delete</span> o.b;</span><br></pre></td></tr></table></figure>

<p>对于新增元素，看似使用第一种方法更为简单，不过它也有些许限制：</p>
<ul>
<li>属性名不能包含空格和标点符号</li>
<li>属性名不能以数字开头</li>
</ul>
<p>对于条件属性访问表达式的更多内容可以看一下这：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6928565118129471496/#heading-5">条件属性访问表达式</a></p>
<p><strong>Map</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">//新增/修改</span></span><br><span class="line">m.set(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">map.get(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">map.delete(<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于简单的增删查改来说，Map 上的方法使用起来也是十分便捷的；不过在进行联动操作时，Map 中的用法则会略显臃肿：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;x&quot;</span>, <span class="number">1</span>]]);</span><br><span class="line"><span class="comment">// 若想要将 x 的值在原有基础上加一，我们需要这么做：</span></span><br><span class="line">m.set(<span class="string">&quot;x&quot;</span>, m.get(<span class="string">&quot;x&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">m.get(<span class="string">&quot;x&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 在对象上修改则会简单许多：</span></span><br><span class="line">o.x++;</span><br><span class="line">o.x; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>接下来我们来讨论一下 Object 和 Map 的性能。不知道各位有没有听说过 Map 的性能优于 Object 的说法，我反正是见过不少次，甚至在 JS 高程四中也提到了 Map 对比 Object 时性能的优势；不过对于性能的概括都十分的笼统，所以我打算做一些测试来对比一下它们的区别。</p>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p>在这里我进行的对于性能测试的都是基于 v8 引擎的。速度会通过 JS 标准库自带的 performance.now() 函数来判断，内存使用情况会通过 Chrome devtool 中的 memory 来查看。</p>
<p>对于速度测试，因为单一的操作速度太快了，很多时候 performance.now() 会返回 0。所以我进行了 10000 次的循环然后判断时间差。因为循环本身也会占据一部分时间，所以以下的测试只能作为一个大致的参考。</p>
<h3 id="创建时的性能"><a href="#创建时的性能" class="headerlink" title="创建时的性能"></a>创建时的性能</h3><p>测试用的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n,</span><br><span class="line">  n2 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 速度</span></span><br><span class="line"><span class="keyword">while</span> (n2--) &#123;</span><br><span class="line">  <span class="keyword">let</span> p1 = performance.now();</span><br><span class="line">  n = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p2 = performance.now();</span><br><span class="line">  n = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p3 = performance.now();</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`Object: <span class="subst">$&#123;(p2 - p1).toFixed(<span class="number">3</span>)&#125;</span>ms, Map: <span class="subst">$&#123;(p3 - p2).toFixed(<span class="number">3</span>)&#125;</span>ms`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test.o = o;</span><br><span class="line">test.m = m;</span><br></pre></td></tr></table></figure>

<p>首先进行对比的是创建 Object 和 Map 时的表现。对于创建的速度表现如下：</p>
<p><img src="/img/js_object_or_map/elem1.jpg"></p>
<p>我们可以发现创建 Object 的速度会快于 Map。对于内存使用情况则如下：</p>
<p><img src="/img/js_object_or_map/elem2.jpg"></p>
<p>我们主要关注其 Retained Size，它表示了为其分配的空间。（即删除时释放的内存大小）</p>
<p>通过对比我们可以发现，空的 Object 会比空的 Map 占用更少的内。所以这一轮 Object 赢得一筹。</p>
<h3 id="新增元素时的性能"><a href="#新增元素时的性能" class="headerlink" title="新增元素时的性能"></a>新增元素时的性能</h3><p>测试用的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.clear();</span><br><span class="line"><span class="keyword">let</span> n,</span><br><span class="line">  n2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;,</span><br><span class="line">  m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">// 速度</span></span><br><span class="line"><span class="keyword">while</span> (n2--) &#123;</span><br><span class="line">  <span class="keyword">let</span> p1 = performance.now();</span><br><span class="line">  n = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    o[<span class="built_in">Math</span>.random()] = <span class="built_in">Math</span>.random();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p2 = performance.now();</span><br><span class="line">  n = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    m.set(<span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> p3 = performance.now();</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`Object: <span class="subst">$&#123;(p2 - p1).toFixed(<span class="number">3</span>)&#125;</span>ms, Map: <span class="subst">$&#123;(p3 - p2).toFixed(<span class="number">3</span>)&#125;</span>ms`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test.o = o;</span><br><span class="line">test.m = m;</span><br></pre></td></tr></table></figure>

<p>对于新建元素时的速度表现如下：</p>
<p><img src="/img/js_object_or_map/elem3.jpg"></p>
<p>我们可以发现新建元素时，Map 的速度会快于 Object。对于内存使用情况则如下：</p>
<p><img src="/img/js_object_or_map/elem4.jpg"></p>
<p>通过对比我们可以发现，在拥有一定数量的元素时， Object 会比 Map 占用多了约 78% 的内存。我也进行了多次的测试，发现在拥有足够的元素时，这个百分比是十分稳定的。所以说，在需要进行很多新增操作，且需要储存许多数据的时候，使用 Map 会更高效。</p>
<h3 id="读取元素时的性能"><a href="#读取元素时的性能" class="headerlink" title="读取元素时的性能"></a>读取元素时的性能</h3><p>测试用的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n;</span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;,</span><br><span class="line">  m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">n = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line">  o[<span class="built_in">Math</span>.random()] = <span class="built_in">Math</span>.random();</span><br><span class="line">&#125;</span><br><span class="line">n = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line">  m.set(<span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = performance.now();</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="keyword">let</span> k = o[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p2 = performance.now();</span><br><span class="line"><span class="keyword">for</span> ([key] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="keyword">let</span> k = m.get(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p3 = performance.now();</span><br><span class="line"><span class="string">`Object: <span class="subst">$&#123;(p2 - p1).toFixed(<span class="number">3</span>)&#125;</span>ms, Map: <span class="subst">$&#123;(p3 - p2).toFixed(<span class="number">3</span>)&#125;</span>ms`</span>;</span><br></pre></td></tr></table></figure>

<p>对于读取元素时的速度表现如下：</p>
<p><img src="/img/js_object_or_map/elem5.jpg"></p>
<p>通过对比，我们可以发现 Object 略占优势，但总体差别不大。</p>
<h3 id="删除元素时的性能"><a href="#删除元素时的性能" class="headerlink" title="删除元素时的性能"></a>删除元素时的性能</h3><p>不知道大家是否听说过 delete 操作符性能低下，甚至有很多时候为了性能，会宁可将值设置为 undefined 而不使用 delete 操作符的说法。但其实在 v8 近来的优化下，它的效率已经提升许多了。</p>
<p>测试用的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n;</span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;,</span><br><span class="line">  m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">n = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line">  o[<span class="built_in">Math</span>.random()] = <span class="built_in">Math</span>.random();</span><br><span class="line">&#125;</span><br><span class="line">n = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line">  m.set(<span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = performance.now();</span><br><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="keyword">delete</span> o[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p2 = performance.now();</span><br><span class="line"><span class="keyword">for</span> ([key] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  m.delete(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p3 = performance.now();</span><br><span class="line"><span class="string">`Object: <span class="subst">$&#123;(p2 - p1).toFixed(<span class="number">3</span>)&#125;</span>ms, Map: <span class="subst">$&#123;(p3 - p2).toFixed(<span class="number">3</span>)&#125;</span>ms`</span>;</span><br></pre></td></tr></table></figure>

<p>对于删除元素时的速度表现如下：</p>
<p><img src="/img/js_object_or_map/elem6.jpg"></p>
<p>我们可以发现在进行删除操作时，Map 的速度会略占优，但整体差别其实并不大。</p>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>其实除了最基本的情况之外，还有一种特殊的情况。还记得我们在前面提到的 Object 中键的排序吗？我们提到了其中的非负整数会被最先列出。其实对于非负整数作为键的值和其余类型作为键的值来说，v8 是会对它们进行区别对待的。负整数作为键的部分会被当成数组对待，即非负整数具有一定的连续性时，会被当成快数组，而过于稀疏时会被当成慢数组。</p>
<p>对于快数组，它拥有连续的内存，所以在进行读写时会更快，且占用更少的内存。更多的内容可以看一下这: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96959371">探究 JS V8 引擎下的“数组”底层实现</a></p>
<p>在键为连续非负整数时，性能如下：</p>
<p><img src="/img/js_object_or_map/elem7.jpg"><br><img src="/img/js_object_or_map/elem8.jpg"></p>
<p>我们可以看到 Object 不仅平均速度更快了，其占用的内存也大大减少了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对比我们可以发现，Map 和 Object 各有千秋，对于不同的情况下，我们应当作出不同的选择。所以我总结了一下我认为使用 Map 和 Object 更为合适的时机。</p>
<p>使用 Map：</p>
<ul>
<li>储存的键不是字符串/数字/或者 Symbol 时，选择 Map，因为 Object 并不支持</li>
<li>储存大量的数据时，选择 Map，因为它占用的内存更小</li>
<li>需要进行许多新增/删除元素的操作时，选择 Map，因为速度更快</li>
<li>需要保持插入时的顺序的话，选择 Map，因为 Object 会改变排序</li>
<li>需要迭代/遍历的话，选择 Map，因为它默认是可迭代对象，迭代更为便捷</li>
</ul>
<p>使用 Object：</p>
<ul>
<li>只是简单的数据结构时，选择 Object，因为它在数据少的时候占用内存更少，且新建时更为高效</li>
<li>需要用到 JSON 进行文件传输时，选择 Object，因为 JSON 不默认支持 Map</li>
<li>需要对多个键值进行运算时，选择 Object，因为句法更为简洁</li>
<li>需要覆盖原型上的键时，选择 Object</li>
</ul>
<p>虽然 Map 在很多情况下会比 Object 更为高效，不过 Object 永远是 JS 中最基本的引用类型，它的作用也不仅仅是为了储存键值对。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>JS 项目中究竟应该使用 Object 还是 Map？</p><p><a href="https://kainonly.com/front-end/js_object_or_map/">https://kainonly.com/front-end/js_object_or_map/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Kain</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-05-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/backend/serverless-1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Serverless（无服务）基础知识</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/backend/why_rpc/"><span class="level-item">既然有 HTTP 请求，为什么还要用 RPC 调用 ?</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://kainonly.com/front-end/js_object_or_map/';
            this.page.identifier = 'front-end/js_object_or_map/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'kains-note' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#用法对比"><span class="level-left"><span class="level-item">用法对比</span></span></a></li><li><a class="level is-mobile" href="#句法对比"><span class="level-left"><span class="level-item">句法对比</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#创建时的区别"><span class="level-left"><span class="level-item">创建时的区别</span></span></a></li><li><a class="level is-mobile" href="#新增-读取-删除元素时的区别"><span class="level-left"><span class="level-item">新增/读取/删除元素时的区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#性能对比"><span class="level-left"><span class="level-item">性能对比</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#测试方法"><span class="level-left"><span class="level-item">测试方法</span></span></a></li><li><a class="level is-mobile" href="#创建时的性能"><span class="level-left"><span class="level-item">创建时的性能</span></span></a></li><li><a class="level is-mobile" href="#新增元素时的性能"><span class="level-left"><span class="level-item">新增元素时的性能</span></span></a></li><li><a class="level is-mobile" href="#读取元素时的性能"><span class="level-left"><span class="level-item">读取元素时的性能</span></span></a></li><li><a class="level is-mobile" href="#删除元素时的性能"><span class="level-left"><span class="level-item">删除元素时的性能</span></span></a></li><li><a class="level is-mobile" href="#特殊情况"><span class="level-left"><span class="level-item">特殊情况</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">前端技术</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">后端技术</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%89%8B%E8%AE%B0/"><span class="level-start"><span class="level-item">手记</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">运维技术</span></span><span class="level-end"><span class="level-item tag">35</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/angular/"><span class="tag">angular</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/certbot/"><span class="tag">certbot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debian/"><span class="tag">debian</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debian-ubuntu/"><span class="tag">debian ubuntu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/electron/"><span class="tag">electron</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/emqx/"><span class="tag">emqx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lumen/"><span class="tag">lumen</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nats/"><span class="tag">nats</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nodejs/"><span class="tag">nodejs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openssl/"><span class="tag">openssl</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgsql/"><span class="tag">postgsql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/satis/"><span class="tag">satis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/window/"><span class="tag">window</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Kain&#039;s Notes" height="28"></a><p class="is-size-7"><span>&copy; 2021 Kain</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7"><a href="https://beian.miit.gov.cn" target="_blank">琼ICP备18004473号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/kainonly"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>